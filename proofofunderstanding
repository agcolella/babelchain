contract ProofOfUnderstanding{
	
	// this contract is intended to call and coordinate the format, 
	//content and action handshake contracts
	// action depends on previous content, content on previous handshake
  
   FormatHandshake formathandshake;
    
    	address public sender;
	address public receiver;
	uint public messageToTranslate;
// should somehow be accessible only for sender, own class ?	
	uint public translationBounty;
    
    
    function CreatedFormatHandshake(bytes32 _name) {
       
        // We do an explicit type conversion from `address`
        // to `FormatHandshake` and assume that the type of
        // the calling contract is TokenCreator, there is
        // no real way to check that.
        formathandshake = FormatHandshake(sender);//, receiver, messageToTranslate, translationBounty);
        //formathandshake.sender = sender;
      
      //  	function FormatHandshake(
	//	address _sender,
	//	address _receiver,
	//	uint  _messageToTranslate,
	//	uint _translationBounty) 
      
    }
    
    
}
// punt in funcs here
contract Sender {}
contract Receiver {}
contract Translator {}

contract FormatHandshakeLearningSet{}

// take out functions here and place in other functions
contract FormatHandshake {
	
	// sender will pay. Receiver and sender can have another independent contract to split costs
	address public sender;
	address public receiver;
	uint public messageToTranslate;
// should somehow be accessible only for sender, own class ?	
	uint public translationBounty;
	
  
	bool receiverAgreedFormat ;
	bool senderAgreedFormat ; 

	address public winningTranslator;
	uint public chosenformat;

	/// Modifiers are a convenient way to validate inputs to
    /// functions. `onlyBefore` is applied to `bid` below:
    /// The new function body is the modifier's body where
    /// `_` is replaced by the old function body.
    modifier payOnlyAfterBothAgreed()	 
	  { if (receiverAgreedFormat != true || senderAgreedFormat != true) 
	   throw; 
	   _ }
	
   
	//modifier onlyAfter(uint _time) { if (now <= _time) throw; _ }

	
	
// the chosenformat should be replaced with a more complex structure 
// of rejected and approved data
// this set should be permanently stored in the babelchain
// it is meant to serve as a training set for translators machine learning

		struct FormatProposal
   {
       bytes32 name;   // short name (up to 32 bytes)
        bytes32 format;   // the suggested format
		bool senderReply;  // if agreed
		bool receiverReply; // if agreed
    	bool contenthandshakeReverse; // reverted, 'cause they couldnt agree on next level ?
		bool actionhandshakeReverse; // reverted, 'cause they couldnt agree on next level ?

    }

	
    // A dynamically-sized array of `Proposal` structs.
	// needs to be permanent
    FormatProposal[] public formatProposals;
	

	event Formatsuggested(address translator);
	event Formatrejected(address rejector);
	event Formatagreed(address approver);
	event formatHandshaked(address approver);
	
	
	function FormatHandshake(
		address _sender,
		address _receiver,
		uint  _messageToTranslate,
		uint _translationBounty) 
	{
	 sender = _sender;
	 receiver = _receiver;
	 messageToTranslate = _messageToTranslate;
	 translationBounty	= _translationBounty;
	 receiverAgreedFormat =  false ;
	 senderAgreedFormat =  false ; 	
	}
	
// Do we need a class the Translator runs this	
   function suggestFormat(uint suggestedformat) {
        // Nsuggest only if not yet found
       // if (formatFound = true ) {throw;}
	   chosenformat = suggestedformat;

	    //event Formatsuggested(address translator, address sender, address receiver, uint format); 
	   senderAgreedFormat = false; 
	   receiverAgreedFormat = false; 


	   //myself
	   //event Formatsuggested(address translator);
   }
 
// should be in class of Sender
	function askSenderApproval()
	
	{
	
	//if(!howcantheSendersettlethatquestion)
	//	{
	//	senderAgreedFormat	= false;
		
	//    Formatrejected(sender);
	//	}
	senderAgreedFormat	= true;
	Formatagreed(sender);
	if(receiverAgreedFormat)
		 formatHandshaked(sender);
	// pay significant part of bounty --> rest gets paid, if content and action dont backtrack here !!!
	winningTranslator.send(this.balance);	
	}
	function payBount()
	 payOnlyAfterBothAgreed()
	{
	
	// pay significant part of bounty --> rest gets paid, if content and action dont backtrack here !!!
	winningTranslator.send(this.balance / 2);	
	}
	
// should be in class of Receiver	
	function askReceiverApproval(){
	//if(!howcantheSendersettlethatquestion)
	//	{
	//	receiverAgreedFormat	= false;
	//    Formatrejected(sender);
	//	}
	receiverAgreedFormat	= true;
	Formatagreed(receiver);
	// we let the sender decide, as he pays
	// he can try claiming back parts of the payment, 
	// if the message was useful for the receiver
	if(senderAgreedFormat)
		 askSenderApproval();	
	}

	function () {
        // This function gets executed if a
        // transaction with invalid data is sent to
        // the contract or just ether without data.
        // We revert the send so that no-one
        // accidentally loses money when using the
        // contract.
        throw;
    }
	
}

contract ContentHandshakeLearningSet{}
contract ContentHandshake {}

contract ActionHandshakeLearningSet{}
contract ActionHandshake {}	
